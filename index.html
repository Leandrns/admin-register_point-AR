<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,viewport-fit=cover">
  <title>WebXR AR Hit Test com Calibra√ß√£o QR</title>
  <style>
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#ddd}
    
    #info{position:fixed;left:10px;top:10px;z-index:2;background:rgba(0,0,0,0.8);padding:15px;border-radius:8px;max-width:300px}
    
    #qr-scanner{
      position:fixed;
      top:0;left:0;width:100%;height:100%;
      background:rgba(0,0,0,0.9);
      display:none;
      z-index:10;
      flex-direction:column;
      align-items:center;
      justify-content:center
    }
    
    #qr-video{width:80%;max-width:400px;border-radius:8px}
    
    #qr-instructions{
      color:#fff;text-align:center;margin:20px;
      font-size:16px;background:rgba(0,0,0,0.7);
      padding:15px;border-radius:8px
    }
    
    .btn{
      background:#007bff;color:#fff;border:none;
      padding:12px 20px;border-radius:6px;
      cursor:pointer;margin:5px;font-size:14px
    }
    
    .btn:hover{background:#0056b3}
    .btn:disabled{background:#666;cursor:not-allowed}
    
    #status{
      position:fixed;bottom:20px;left:20px;
      background:rgba(0,0,0,0.8);padding:10px;
      border-radius:6px;z-index:5
    }
    
    .status-calibrado{color:#00ff00}
    .status-nao-calibrado{color:#ff6600}
    
    canvas{display:block}
  </style>
</head>
<body>
  <div id="info">
    <strong>WebXR AR com Calibra√ß√£o QR</strong><br>
    <div id="calibration-status" class="status-nao-calibrado">
      ‚ùå N√£o calibrado
    </div>
    <button id="calibrate-btn" class="btn">Calibrar com QR Code</button>
    <br><br>
    <div id="instructions">
      1. Primeiro, fa√ßa a calibra√ß√£o<br>
      2. Depois toque no ret√≠culo para criar cubos
    </div>
  </div>

  <!-- Scanner QR Code -->
  <div id="qr-scanner">
    <div id="qr-instructions">
      <h3>Calibra√ß√£o do Sistema</h3>
      <p>Aponte a c√¢mera para o QR Code do evento.</p>
      <p>Este QR deve estar no ponto de entrada ou refer√™ncia do local.</p>
    </div>
    <video id="qr-video" autoplay muted playsinline></video>
    <button id="cancel-qr" class="btn">Cancelar</button>
  </div>

  <div id="status">
    <div id="points-count">Pontos criados: 0</div>
  </div>

  <!-- QR Code Scanner Library -->
  <script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.148.0/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.148.0/examples/jsm/webxr/ARButton.js';

    let camera, scene, renderer;
    let controller;
    let reticle;

    let hitTestSource = null;
    let localReferenceSpace = null;

    // Sistema de calibra√ß√£o
    let pontoReferencia = null;
    let calibrado = false;
    let pontosCreated = 0;
    let pontosCarregados = []; // Array para gerenciar pontos carregados

    // QR Scanner
    let qrStream = null;
    let qrScanning = false;

    init();
    animate();

    function init(){
      const container = document.createElement('div');
      document.body.appendChild(container);

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

      // Luzes
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      container.appendChild(renderer.domElement);

      document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

      // Reticle
      const geometry = new THREE.RingGeometry(0.06, 0.08, 32).rotateX(-Math.PI/2);
      const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      reticle = new THREE.Mesh(geometry, material);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      // Controller
      controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelect);
      scene.add(controller);

      // Event listeners
      window.addEventListener('resize', onWindowResize);
      renderer.xr.addEventListener('sessionstart', onSessionStart);
      renderer.xr.addEventListener('sessionend', onSessionEnd);

      // QR Calibration setup
      setupQRCalibration();
    }

    function setupQRCalibration() {
      const calibrateBtn = document.getElementById('calibrate-btn');
      const cancelBtn = document.getElementById('cancel-qr');

      calibrateBtn.addEventListener('click', startQRScanning);
      cancelBtn.addEventListener('click', stopQRScanning);
    }

    async function startQRScanning() {
      try {
        const qrScanner = document.getElementById('qr-scanner');
        const video = document.getElementById('qr-video');

        qrScanner.style.display = 'flex';
        qrScanning = true;

        // Acessar c√¢mera
        qrStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment' } // c√¢mera traseira
        });

        video.srcObject = qrStream;
        video.play();

        // Iniciar scanning
        scanQRCode(video);

      } catch (error) {
        console.error('Erro ao acessar c√¢mera:', error);
        alert('N√£o foi poss√≠vel acessar a c√¢mera');
        stopQRScanning();
      }
    }

    function scanQRCode(video) {
      if (!qrScanning) return;

      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');

      function tick() {
        if (!qrScanning) return;

        if (video.readyState === video.HAVE_ENOUGH_DATA) {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          context.drawImage(video, 0, 0, canvas.width, canvas.height);

          const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
          const code = jsQR(imageData.data, imageData.width, imageData.height);

          if (code) {
            // QR Code detectado!
            processQRCode(code.data);
            return;
          }
        }

        requestAnimationFrame(tick);
      }
      tick();
    }

    function processQRCode(qrData) {
      console.log('QR Code detectado:', qrData);

      // Validar se √© um QR Code de evento v√°lido
      if (qrData.includes('QR') || qrData.includes('calibracao') || qrData.length > 5) {
        // Simular defini√ß√£o do ponto de refer√™ncia
        definirPontoReferencia(qrData);
        stopQRScanning();
      } else {
        alert('QR Code inv√°lido. Use um QR Code de evento v√°lido.');
      }
    }

    function definirPontoReferencia(qrData) {
      // Definir ponto de refer√™ncia baseado no QR Code
      pontoReferencia = {
        qrCode: qrData,
        timestamp: Date.now(),
        // Em uma implementa√ß√£o real, voc√™ salvaria a posi√ß√£o GPS aqui
        gps: null,
        // Posi√ß√£o ser√° definida quando entrar em AR
        arPosition: null
      };

      calibrado = true;
      updateCalibrationUI();
      
      // Mostrar quantos pontos salvos existem para este QR
      const pontosSalvos = JSON.parse(localStorage.getItem('pontos') || '[]');
      const pontosDoEvento = pontosSalvos.filter(p => p.qrReferencia === qrData);
      
      console.log('Sistema calibrado com QR Code:', qrData);
      console.log(`${pontosDoEvento.length} pontos encontrados para este evento`);
      
      alert(`Calibra√ß√£o realizada!\nEncontrados ${pontosDoEvento.length} pontos salvos.\nEntre no modo AR para visualiz√°-los.`);
    }

    function stopQRScanning() {
      qrScanning = false;
      
      if (qrStream) {
        qrStream.getTracks().forEach(track => track.stop());
        qrStream = null;
      }

      document.getElementById('qr-scanner').style.display = 'none';
    }

    function updateCalibrationUI() {
      const statusEl = document.getElementById('calibration-status');
      const calibrateBtn = document.getElementById('calibrate-btn');

      if (calibrado) {
        statusEl.innerHTML = '‚úÖ Sistema Calibrado';
        statusEl.className = 'status-calibrado';
        calibrateBtn.textContent = 'Recalibrar';
        
        // Mostrar informa√ß√µes do QR atual
        const pontosSalvos = JSON.parse(localStorage.getItem('pontos') || '[]');
        const pontosDoEvento = pontosSalvos.filter(p => 
          pontoReferencia && p.qrReferencia === pontoReferencia.qrCode
        );
        
        document.getElementById('instructions').innerHTML = 
          `<strong>QR:</strong> ${pontoReferencia?.qrCode}<br>
           <strong>Pontos salvos:</strong> ${pontosDoEvento.length}<br>
           Toque no ret√≠culo para criar novos cubos`;
      } else {
        statusEl.innerHTML = '‚ùå N√£o calibrado';
        statusEl.className = 'status-nao-calibrado';
        calibrateBtn.textContent = 'Calibrar com QR Code';
        
        document.getElementById('instructions').innerHTML = 
          '1. Primeiro, fa√ßa a calibra√ß√£o<br>2. Depois toque no ret√≠culo para criar cubos';
      }
    }

    function onSessionStart(){
      const session = renderer.xr.getSession();

      session.requestReferenceSpace('viewer').then(function(viewerReferenceSpace){
        session.requestHitTestSource({ space: viewerReferenceSpace }).then(function(source){
          hitTestSource = source;
        });
      });

      session.requestReferenceSpace('local').then(function(refSpace){
        localReferenceSpace = refSpace;
        
        // Se calibrado, definir posi√ß√£o de refer√™ncia AR e carregar pontos
        if (calibrado && pontoReferencia) {
          if (!pontoReferencia.arPosition) {
            // Primeira vez definindo o ponto de refer√™ncia
            pontoReferencia.arPosition = new THREE.Vector3(0, 0, 0);
          }
          
          // Carregar pontos salvos sempre que iniciar uma nova sess√£o AR
          setTimeout(() => {
            carregarPontosSalvos();
          }, 1000); // Aguarda um pouco para estabilizar o tracking
          
          console.log('Ponto de refer√™ncia AR definido e pontos sendo carregados');
        }
      });
    }

    function onSessionEnd(){
      hitTestSource = null;
      localReferenceSpace = null;
      reticle.visible = false;
      
      // Limpar objetos AR da sess√£o anterior (mas manter os dados)
      limparObjetosAR();
    }

    function limparObjetosAR() {
      // Remove apenas os cubos da cena, mantendo reticle, luzes, etc.
      const objetosParaRemover = [];
      scene.traverse((child) => {
        if (child.isMesh && child.geometry && child.geometry.type === 'BoxGeometry') {
          objetosParaRemover.push(child);
        }
      });
      
      objetosParaRemover.forEach(obj => {
        scene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) obj.material.dispose();
      });
      
      pontosCarregados = [];
      console.log('Objetos AR da sess√£o anterior removidos');
    }

    function onSelect(){
      if (!calibrado) {
        alert('Fa√ßa a calibra√ß√£o primeiro!');
        return;
      }

      if (!reticle.visible) return;

      // Criar cubo
      const boxGeo = new THREE.BoxGeometry(0.12, 0.12, 0.12);
      const boxMat = new THREE.MeshStandardMaterial({ 
        roughness: 0.7, 
        metalness: 0.0,
        color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5)
      });
      const box = new THREE.Mesh(boxGeo, boxMat);

      // Posicionar baseado no reticle
      const position = new THREE.Vector3();
      position.setFromMatrixPosition(reticle.matrix);
      
      // Calcular posi√ß√£o relativa ao ponto de refer√™ncia
      const posicaoRelativa = calcularPosicaoRelativa(position);
      
      box.position.copy(position);
      scene.add(box);

      // Salvar ponto (em uma implementa√ß√£o real, enviaria para backend)
      salvarPonto(posicaoRelativa);

      pontosCreated++;
      
      // Atualizar contador considerando pontos carregados
      const pontosSalvosTotal = JSON.parse(localStorage.getItem('pontos') || '[]')
        .filter(p => p.qrReferencia === pontoReferencia.qrCode).length;
      const novosTotal = pontosCreated - pontosCarregados.length;
      
      document.getElementById('points-count').textContent = 
        `Pontos: ${pontosSalvosTotal} salvos + ${novosTotal} novos = ${pontosSalvosTotal + novosTotal} total`;
    }

    function calcularPosicaoRelativa(posicaoAR) {
      if (!pontoReferencia || !pontoReferencia.arPosition) {
        return posicaoAR.clone();
      }

      // Calcular posi√ß√£o relativa ao ponto de refer√™ncia
      return posicaoAR.clone().sub(pontoReferencia.arPosition);
    }

    function salvarPonto(posicaoRelativa) {
      const ponto = {
        id: generateId(),
        posicaoRelativa: {
          x: posicaoRelativa.x,
          y: posicaoRelativa.y,
          z: posicaoRelativa.z
        },
        qrReferencia: pontoReferencia.qrCode,
        timestamp: Date.now(),
        tipo: 'cubo'
      };

      console.log('Ponto salvo:', ponto);
      
      // Em uma implementa√ß√£o real, voc√™ enviaria para o backend:
      // await enviarPontoParaBackend(ponto);
      
      // Por enquanto, salva no localStorage para demonstra√ß√£o
      const pontosSalvos = JSON.parse(localStorage.getItem('pontos') || '[]');
      pontosSalvos.push(ponto);
      localStorage.setItem('pontos', JSON.stringify(pontosSalvos));
    }

    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    function onWindowResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate(){
      renderer.setAnimationLoop(render);
    }

    function render(timestamp, frame){
      if (frame){
        const referenceSpace = localReferenceSpace;

        if (hitTestSource && referenceSpace){
          const hitTestResults = frame.getHitTestResults(hitTestSource);

          if (hitTestResults.length > 0){
            const hit = hitTestResults[0];
            const pose = hit.getPose(referenceSpace);

            reticle.visible = calibrado; // s√≥ mostra se calibrado
            if (calibrado) {
              reticle.matrix.fromArray(pose.transform.matrix);
            }
          } else {
            reticle.visible = false;
          }
        }
      }

      renderer.render(scene, camera);
    }

    function carregarPontosSalvos() {
      if (!calibrado || !pontoReferencia) return;

      const pontosSalvos = JSON.parse(localStorage.getItem('pontos') || '[]');
      
      // Filtrar pontos do mesmo QR Code de refer√™ncia
      const pontosDoEvento = pontosSalvos.filter(ponto => 
        ponto.qrReferencia === pontoReferencia.qrCode
      );

      console.log(`Carregando ${pontosDoEvento.length} pontos salvos...`);

      pontosDoEvento.forEach((ponto, index) => {
        // Calcular posi√ß√£o absoluta a partir da relativa
        const posicaoAbsoluta = new THREE.Vector3(
          ponto.posicaoRelativa.x,
          ponto.posicaoRelativa.y,
          ponto.posicaoRelativa.z
        );

        // Adicionar ponto de refer√™ncia atual
        if (pontoReferencia.arPosition) {
          posicaoAbsoluta.add(pontoReferencia.arPosition);
        }

        // Criar cubo visual
        criarCuboCarregado(posicaoAbsoluta, ponto, index);
      });

      // Atualizar contador visual
      const totalPontos = pontosDoEvento.length + (pontosCreated - pontosCarregados.length);
      document.getElementById('points-count').textContent = 
        `Pontos: ${pontosDoEvento.length} salvos + ${pontosCreated - pontosCarregados.length} novos = ${totalPontos} total`;
    }

    function criarCuboCarregado(posicao, dadosPonto, index) {
      const boxGeo = new THREE.BoxGeometry(0.12, 0.12, 0.12);
      
      // Cor diferente para pontos carregados (mais escura)
      const boxMat = new THREE.MeshStandardMaterial({ 
        roughness: 0.8, 
        metalness: 0.2,
        color: new THREE.Color().setHSL((index * 0.1) % 1, 0.5, 0.4) // Cores mais escuras
      });
      
      const box = new THREE.Mesh(boxGeo, boxMat);
      box.position.copy(posicao);
      
      // Marcar como ponto carregado para n√£o salvar novamente
      box.userData = {
        carregado: true,
        dadosOriginais: dadosPonto
      };
      
      scene.add(box);
      pontosCarregados.push(box);
      
      console.log(`Cubo carregado na posi√ß√£o:`, posicao);
    }

	// Carregar informa√ß√µes ao inicializar p√°gina
    window.addEventListener('load', () => {
      const pontosSalvos = JSON.parse(localStorage.getItem('pontos') || '[]');
      console.log('Pontos salvos encontrados:', pontosSalvos.length);
      
      // Se j√° temos pontos salvos, mostrar dica
      if (pontosSalvos.length > 0) {
        document.getElementById('instructions').innerHTML += 
          '<br><br><em>üí° Pontos salvos encontrados! Calibre para visualiz√°-los.</em>';
      }
    });

  </script>
</body>
</html>