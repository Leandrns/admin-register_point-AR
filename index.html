<!DOCTYPE html>
<html lang="pt-BR">
	<head>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width,initial-scale=1,minimum-scale=1,viewport-fit=cover"
		/>
		<title>WebXR AR Hit Test + js-aruco Marker Detection</title>
		<style>
			html,
			body {
				height: 100%;
				margin: 0;
				background: #111;
				color: #ddd;
				font-family: Arial;
			}
			#info {
				position: fixed;
				left: 10px;
				top: 10px;
				z-index: 3;
				background: rgba(0, 0, 0, 0.5);
				padding: 10px;
				border-radius: 8px;
				max-width: 320px;
			}
			#pontos {
				position: fixed;
				bottom: 10px;
				left: 10px;
				z-index: 3;
				background: rgba(0, 0, 0, 0.5);
				padding: 10px;
				border-radius: 8px;
				font-size: 12px;
				max-width: 320px;
				white-space: pre-wrap;
			}
			#aruco-overlay {
				position: fixed;
				top: 0;
				left: 0;
				width: 100vw;
				height: 100vh;
				background: rgba(0, 0, 0, 0.85);
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				color: white;
				font-size: 18px;
				z-index: 10;
			}
			video {
				width: 320px;
				height: 240px;
				border: 2px solid #0f0;
				border-radius: 10px;
			}
		</style>
	</head>
	<body>
		<div id="aruco-overlay">
			<div>Aponte a câmera para o marcador ArUco para calibrar a origem.</div>
			<video id="aruco-video" playsinline></video>
			<canvas id="aruco-canvas" style="display: none"></canvas>
			<div style="margin-top: 10px; font-size: 14px; color: #0f0" id="aruco-result">
				Aguardando marcador...
			</div>
			<button id="start-ar-btn" style="margin-top: 10px; display: none">
				Iniciar AR
			</button>
		</div>

		<div id="info" style="display: none">
			<strong>WebXR AR Hit Test + ArUco Marker</strong><br />
			Toque no retículo para colocar um cubo.<br />
		</div>

		<div id="pontos">
			<strong>Pontos salvos:</strong><br /><span id="listaPontos"></span>
		</div>

		<script type="module">
			import * as THREE from "https://unpkg.com/three@0.148.0/build/three.module.js";
			import { ARButton } from "https://unpkg.com/three@0.148.0/examples/jsm/webxr/ARButton.js";

			// Import js-aruco (via CDN UMD) - usamos script tag abaixo para carregar global Aruco
			// Mas aqui a gente vai fazer um truque pra importar (vai ter um <script> abaixo)

			let camera, scene, renderer;
			let controller, reticle;
			let hitTestSource = null;
			let localReferenceSpace = null;

			let marcadorOrigem = null; // THREE.Matrix4 da pose do marcador detectado
			let pontosSalvos = [];

			const arucoOverlay = document.getElementById("aruco-overlay");
			const arucoVideo = document.getElementById("aruco-video");
			const arucoCanvas = document.getElementById("aruco-canvas");
			const arucoCtx = arucoCanvas.getContext("2d");
			const arucoResult = document.getElementById("aruco-result");
			const startARBtn = document.getElementById("start-ar-btn");
			const infoDiv = document.getElementById("info");
			const listaPontosSpan = document.getElementById("listaPontos");

			let videoStream = null;
			let scanning = false;

			// Parâmetros para detecção ArUco
			const markerSize = 0.1; // tamanho real do marcador em metros (ajuste conforme seu marcador físico)

			let detector, posit;

			async function startArucoScanner() {
				try {
					videoStream = await navigator.mediaDevices.getUserMedia({
						video: { facingMode: "environment" },
					});
					arucoVideo.srcObject = videoStream;
					await arucoVideo.play();
					scanning = true;

					// Ajusta canvas para o tamanho do vídeo
					arucoCanvas.width = arucoVideo.videoWidth;
					arucoCanvas.height = arucoVideo.videoHeight;

					detector = new AR.Detector();
					posit = new POS.Posit(markerSize, arucoCanvas.width);

					scanLoop();
				} catch (e) {
					arucoResult.textContent = "Erro ao acessar a câmera: " + e.message;
				}
			}

			function stopArucoScanner() {
				if (videoStream) {
					videoStream.getTracks().forEach((track) => track.stop());
					videoStream = null;
				}
				scanning = false;
			}

			function scanLoop() {
				if (!scanning) return;
				if (arucoVideo.readyState === arucoVideo.HAVE_ENOUGH_DATA) {
					arucoCtx.drawImage(arucoVideo, 0, 0, arucoCanvas.width, arucoCanvas.height);
					let imageData = arucoCtx.getImageData(
						0,
						0,
						arucoCanvas.width,
						arucoCanvas.height
					);
					let markers = detector.detect(imageData);

					if (markers.length > 0) {
						arucoResult.textContent = "Marcador detectado! ID: " + markers[0].id;

						// Estimar pose
						let corners = markers[0].corners;

						// Corrigir coordenadas pois js-aruco usa origem diferente (embaixo à esquerda)
						for (let i = 0; i < corners.length; i++) {
							let corner = corners[i];
							corner.x -= arucoCanvas.width / 2;
							corner.y = arucoCanvas.height / 2 - corner.y;
						}

						let pose = posit.pose(corners);

						// Montar matriz 4x4 do pose para three.js
						marcadorOrigem = poseToMatrix(pose);

						stopArucoScanner();

						arucoOverlay.style.display = "none";
						infoDiv.style.display = "block";
						startARBtn.style.display = "inline-block";

						return;
					} else {
						arucoResult.textContent = "Aguardando marcador...";
					}
				}
				requestAnimationFrame(scanLoop);
			}

			function poseToMatrix(pose) {
				// pose.bestRotation é array 3x3 (row major)
				// pose.bestTranslation é array 3

				const rot = pose.bestRotation;
				const trans = pose.bestTranslation;

				const mat = new THREE.Matrix4();

				// construir matriz 4x4 manualmente
				mat.set(
					rot[0][0],
					rot[0][1],
					rot[0][2],
					trans[0],
					rot[1][0],
					rot[1][1],
					rot[1][2],
					trans[1],
					rot[2][0],
					rot[2][1],
					rot[2][2],
					trans[2],
					0,
					0,
					0,
					1
				);

				// Ajuste do sistema de coordenadas (invertendo Y e Z) pode ser necessário conforme calibração

				return mat;
			}

			startARBtn.addEventListener("click", () => {
				startARBtn.style.display = "none";
				initAR();
				animate();
			});

			function initAR() {
				const container = document.createElement("div");
				document.body.appendChild(container);

				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(
					70,
					window.innerWidth / window.innerHeight,
					0.01,
					20
				);

				const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
				light.position.set(0.5, 1, 0.25);
				scene.add(light);

				renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.xr.enabled = true;
				container.appendChild(renderer.domElement);

				document.body.appendChild(
					ARButton.createButton(renderer, { requiredFeatures: ["hit-test"] })
				);

				const geometry = new THREE.RingGeometry(0.06, 0.08, 32).rotateX(-Math.PI / 2);
				const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
				reticle = new THREE.Mesh(geometry, material);
				reticle.matrixAutoUpdate = false;
				reticle.visible = false;
				scene.add(reticle);

				controller = renderer.xr.getController(0);
				controller.addEventListener("select", onSelect);
				scene.add(controller);

				window.addEventListener("resize", onWindowResize);

				renderer.xr.addEventListener("sessionstart", onSessionStart);
				renderer.xr.addEventListener("sessionend", onSessionEnd);
			}

			function onSessionStart() {
				const session = renderer.xr.getSession();

				session.requestReferenceSpace("viewer").then((viewerRefSpace) => {
					session.requestHitTestSource({ space: viewerRefSpace }).then((source) => {
						hitTestSource = source;
					});
				});

				session.requestReferenceSpace("local").then((refSpace) => {
					localReferenceSpace = refSpace;
				});
			}

			function onSessionEnd() {
				hitTestSource = null;
				localReferenceSpace = null;
				reticle.visible = false;
				pontosSalvos = [];
				marcadorOrigem = null;
				listaPontosSpan.textContent = "";
			}

			function onSelect() {
				if (!reticle.visible) return;

				const pos = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);

				// Salvar posição relativa ao marcadorOrigem (transformando posição global para local)
				let posRelativa = pos.clone();

				if (marcadorOrigem) {
					// matriz inversa do marcador para transformar global -> local
					const inversa = new THREE.Matrix4().copy(marcadorOrigem).invert();
					posRelativa.applyMatrix4(inversa);
				}

				pontosSalvos.push(posRelativa);
				alert(
					`Posição salva:\nX: ${posRelativa.x.toFixed(2)}\nY: ${posRelativa.y.toFixed(
						2
					)}\nZ: ${posRelativa.z.toFixed(2)}`
				);

				const boxGeo = new THREE.BoxGeometry(0.12, 0.12, 0.12);
				const boxMat = new THREE.MeshStandardMaterial({
					roughness: 0.7,
					metalness: 0.0,
				});
				const box = new THREE.Mesh(boxGeo, boxMat);
				box.position.copy(pos);
				scene.add(box);
			}

			function onWindowResize() {
				if (camera) {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
				}
				if (renderer) {
					renderer.setSize(window.innerWidth, window.innerHeight);
				}
			}

			function animate() {
				renderer.setAnimationLoop(render);
			}

			function render(timestamp, frame) {
				if (frame) {
					const referenceSpace = localReferenceSpace;

					if (hitTestSource && referenceSpace) {
						const hitTestResults = frame.getHitTestResults(hitTestSource);
						if (hitTestResults.length > 0) {
							const hit = hitTestResults[0];
							const pose = hit.getPose(referenceSpace);
							reticle.visible = true;
							reticle.matrix.fromArray(pose.transform.matrix);
						} else {
							reticle.visible = false;
						}
					}
				}
				renderer.render(scene, camera);
			}

			// Inicia o scanner ArUco no carregamento
			startArucoScanner();
		</script>

		<!-- Import js-aruco e posit.js via CDN -->
		<script src="https://cdn.jsdelivr.net/gh/jcmellado/js-aruco@master/build/aruco.js"></script>
		<script src="https://cdn.jsdelivr.net/gh/jcmellado/js-aruco@master/build/posit1.js"></script>
	</body>
</html>
