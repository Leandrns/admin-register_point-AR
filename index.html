<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,viewport-fit=cover">
  <title>WebXR AR Hit Test com Calibração QR</title>
  <style>
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#ddd}
    
    #info{position:fixed;left:10px;top:10px;z-index:2;background:rgba(0,0,0,0.8);padding:15px;border-radius:8px;max-width:300px}
    
    #qr-scanner{
      position:fixed;
      top:0;left:0;width:100%;height:100%;
      background:rgba(0,0,0,0.9);
      display:none;
      z-index:10;
      flex-direction:column;
      align-items:center;
      justify-content:center
    }
    
    #qr-video{width:80%;max-width:400px;border-radius:8px}
    
    #qr-instructions{
      color:#fff;text-align:center;margin:20px;
      font-size:16px;background:rgba(0,0,0,0.7);
      padding:15px;border-radius:8px
    }
    
    .btn{
      background:#007bff;color:#fff;border:none;
      padding:12px 20px;border-radius:6px;
      cursor:pointer;margin:5px;font-size:14px
    }
    
    .btn:hover{background:#0056b3}
    .btn:disabled{background:#666;cursor:not-allowed}
    
    #status{
      position:fixed;bottom:20px;left:20px;
      background:rgba(0,0,0,0.8);padding:10px;
      border-radius:6px;z-index:5
    }
    
    .status-calibrado{color:#00ff00}
    .status-nao-calibrado{color:#ff6600}
    
    canvas{display:block}
  </style>
</head>
<body>
  <div id="info">
    <strong>WebXR AR com Calibração QR</strong><br>
    <div id="calibration-status" class="status-nao-calibrado">
      ❌ Não calibrado
    </div>
    <button id="calibrate-btn" class="btn">Calibrar com QR Code</button>
    <br><br>
    <div id="instructions">
      1. Primeiro, faça a calibração<br>
      2. Depois toque no retículo para criar cubos
    </div>
  </div>

  <!-- Scanner QR Code -->
  <div id="qr-scanner">
    <div id="qr-instructions">
      <h3>Calibração do Sistema</h3>
      <p>Aponte a câmera para o QR Code do evento.</p>
      <p>Este QR deve estar no ponto de entrada ou referência do local.</p>
    </div>
    <video id="qr-video" autoplay muted playsinline></video>
    <button id="cancel-qr" class="btn">Cancelar</button>
  </div>

  <div id="status">
    <div id="points-count">Pontos criados: 0</div>
  </div>

  <!-- QR Code Scanner Library -->
  <script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.148.0/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.148.0/examples/jsm/webxr/ARButton.js';

    let camera, scene, renderer;
    let controller;
    let reticle;

    let hitTestSource = null;
    let localReferenceSpace = null;

    // Sistema de calibração
    let pontoReferencia = null;
    let calibrado = false;
    let pontosCreated = 0;
    let pontosCarregados = []; // Array para gerenciar pontos carregados

    // QR Scanner
    let qrStream = null;
    let qrScanning = false;

    init();
    animate();

    function init(){
      const container = document.createElement('div');
      document.body.appendChild(container);

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

      // Luzes
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      container.appendChild(renderer.domElement);

      document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

      // Reticle
      const geometry = new THREE.RingGeometry(0.06, 0.08, 32).rotateX(-Math.PI/2);
      const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      reticle = new THREE.Mesh(geometry, material);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      // Controller
      controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelect);
      scene.add(controller);

      // Event listeners
      window.addEventListener('resize', onWindowResize);
      renderer.xr.addEventListener('sessionstart', onSessionStart);
      renderer.xr.addEventListener('sessionend', onSessionEnd);

      // QR Calibration setup
      setupQRCalibration();
    }

    function setupQRCalibration() {
      const calibrateBtn = document.getElementById('calibrate-btn');
      const cancelBtn = document.getElementById('cancel-qr');

      calibrateBtn.addEventListener('click', startQRScanning);
      cancelBtn.addEventListener('click', stopQRScanning);
    }

    async function startQRScanning() {
      try {
        const qrScanner = document.getElementById('qr-scanner');
        const video = document.getElementById('qr-video');

        qrScanner.style.display = 'flex';
        qrScanning = true;

        // Acessar câmera
        qrStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment' } // câmera traseira
        });

        video.srcObject = qrStream;
        video.play();

        // Iniciar scanning
        scanQRCode(video);

      } catch (error) {
        console.error('Erro ao acessar câmera:', error);
        alert('Não foi possível acessar a câmera');
        stopQRScanning();
      }
    }

    function scanQRCode(video) {
      if (!qrScanning) return;

      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');

      function tick() {
        if (!qrScanning) return;

        if (video.readyState === video.HAVE_ENOUGH_DATA) {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          context.drawImage(video, 0, 0, canvas.width, canvas.height);

          const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
          const code = jsQR(imageData.data, imageData.width, imageData.height);

          if (code) {
            // QR Code detectado!
            processQRCode(code.data);
            return;
          }
        }

        requestAnimationFrame(tick);
      }
      tick();
    }

    function processQRCode(qrData) {
      console.log('QR Code detectado:', qrData);

      // Validar se é um QR Code de evento válido
      if (qrData.includes('QR') || qrData.includes('calibracao') || qrData.length > 5) {
        // Simular definição do ponto de referência
        definirPontoReferencia(qrData);
        stopQRScanning();
      } else {
        alert('QR Code inválido. Use um QR Code de evento válido.');
      }
    }

    function definirPontoReferencia(qrData) {
      // Definir ponto de referência baseado no QR Code
      pontoReferencia = {
        qrCode: qrData,
        timestamp: Date.now(),
        // Em uma implementação real, você salvaria a posição GPS aqui
        gps: null,
        // Posição será definida quando entrar em AR
        arPosition: null
      };

      calibrado = true;
      updateCalibrationUI();
      
      console.log('Sistema calibrado com QR Code:', qrData);
      
      alert(`Calibração realizada!\nEntre no modo AR para visualizá-los.`);
    }

    function stopQRScanning() {
      qrScanning = false;
      
      if (qrStream) {
        qrStream.getTracks().forEach(track => track.stop());
        qrStream = null;
      }

      document.getElementById('qr-scanner').style.display = 'none';
    }

    function updateCalibrationUI() {
      const statusEl = document.getElementById('calibration-status');
      const calibrateBtn = document.getElementById('calibrate-btn');

      if (calibrado) {
        statusEl.innerHTML = '✅ Sistema Calibrado';
        statusEl.className = 'status-calibrado';
        calibrateBtn.textContent = 'Recalibrar';
        
        document.getElementById('instructions').innerHTML = 
          `<strong>QR:</strong> ${pontoReferencia?.qrCode}<br>
           Toque no retículo para criar novos cubos`;
      } else {
        statusEl.innerHTML = '❌ Não calibrado';
        statusEl.className = 'status-nao-calibrado';
        calibrateBtn.textContent = 'Calibrar com QR Code';
        
        document.getElementById('instructions').innerHTML = 
          '1. Primeiro, faça a calibração<br>2. Depois toque no retículo para criar cubos';
      }
    }

    function onSessionStart(){
      const session = renderer.xr.getSession();

      session.requestReferenceSpace('viewer').then(function(viewerReferenceSpace){
        session.requestHitTestSource({ space: viewerReferenceSpace }).then(function(source){
          hitTestSource = source;
        });
      });

      session.requestReferenceSpace('local').then(function(refSpace){
        localReferenceSpace = refSpace;
        
        // Se calibrado, definir posição de referência AR e carregar pontos
        if (calibrado && pontoReferencia) {
          if (!pontoReferencia.arPosition) {
            // Primeira vez definindo o ponto de referência
            pontoReferencia.arPosition = new THREE.Vector3(0, 0, 0);
          }
        }
      });
    }

    function onSessionEnd(){
      hitTestSource = null;
      localReferenceSpace = null;
      reticle.visible = false;
      
      // Limpar objetos AR da sessão anterior (mas manter os dados)
      limparObjetosAR();
    }

    function limparObjetosAR() {
      // Remove apenas os cubos da cena, mantendo reticle, luzes, etc.
      const objetosParaRemover = [];
      scene.traverse((child) => {
        if (child.isMesh && child.geometry && child.geometry.type === 'BoxGeometry') {
          objetosParaRemover.push(child);
        }
      });
      
      objetosParaRemover.forEach(obj => {
        scene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) obj.material.dispose();
      });
      
      pontosCarregados = [];
      console.log('Objetos AR da sessão anterior removidos');
    }

    function onSelect(){
      if (!calibrado) {
        alert('Faça a calibração primeiro!');
        return;
      }

      if (!reticle.visible) return;

      // Criar cubo
      const boxGeo = new THREE.BoxGeometry(0.12, 0.12, 0.12);
      const boxMat = new THREE.MeshStandardMaterial({ 
        roughness: 0.7, 
        metalness: 0.0,
        color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5)
      });
      const box = new THREE.Mesh(boxGeo, boxMat);

      // Posicionar baseado no reticle
      const position = new THREE.Vector3();
      position.setFromMatrixPosition(reticle.matrix);
      
      // Calcular posição relativa ao ponto de referência
      const posicaoRelativa = calcularPosicaoRelativa(position);
      
      box.position.copy(position);
      scene.add(box);

      // Salvar ponto (em uma implementação real, enviaria para backend)
      salvarPonto(posicaoRelativa);

      pontosCreated++;
    }

    function calcularPosicaoRelativa(posicaoAR) {
      if (!pontoReferencia || !pontoReferencia.arPosition) {
        return posicaoAR.clone();
      }

      // Calcular posição relativa ao ponto de referência
      return posicaoAR.clone().sub(pontoReferencia.arPosition);
    }

    function salvarPonto(posicaoRelativa) {
      const ponto = {
        id: generateId(),
        posicaoRelativa: {
          x: posicaoRelativa.x,
          y: posicaoRelativa.y,
          z: posicaoRelativa.z
        },
        qrReferencia: pontoReferencia.qrCode,
        timestamp: Date.now(),
        tipo: 'cubo'
      };

      console.log('Ponto salvo:', ponto);
      
      // Em uma implementação real, você enviaria para o backend:
      // await enviarPontoParaBackend(ponto);
    }

    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    function onWindowResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate(){
      renderer.setAnimationLoop(render);
    }

    function render(timestamp, frame){
      if (frame){
        const referenceSpace = localReferenceSpace;

        if (hitTestSource && referenceSpace){
          const hitTestResults = frame.getHitTestResults(hitTestSource);

          if (hitTestResults.length > 0){
            const hit = hitTestResults[0];
            const pose = hit.getPose(referenceSpace);

            reticle.visible = calibrado; // só mostra se calibrado
            if (calibrado) {
              reticle.matrix.fromArray(pose.transform.matrix);
            }
          } else {
            reticle.visible = false;
          }
        }
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>